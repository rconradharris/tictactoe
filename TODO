- Use uv [DONE]
- Use mypy typechecking [DONE]
- Create board and game model [DONE]
- Save move history [DONE]
- Define PGN equivalent for tic-tac-toe [DONE]
    - algebraic tic-tac-toe: at3 [DONE]
- Rewrite tests using this format [DONE]
- Successfully play tic tac toe [DONE]
- Support m,n,k games
    - win_count [DONE]
    - remove square requirement on board [DONE]
- Rename mark to piece [DONE]
- Support connect four [DONE]
    - 7,6,4
    - fix diagonal checks for arbitrary size boards [DONE]
    - placement rule to at3 [DONE]
    - add placement rule to board [DONE]
    - enforce piece placement rules [DONE]
- Add Game enum to AT3 as shorthand for 7,6,4:column stack [DONE]
- Infer game choice from extension, if possible [DONE]
    - .ttt -> TIC_TAC_TOE [DONE]
    - .c4 -> CONNECT_FOUR [DONE]
- Replace Cat Game with Draw since connect four is supported [DONE]
- Add Board.reset(), call in Game.reset() [DONE]
- 3D tic-tac-toe
- Add at3.format()
- Add interactive command to write at3 file


In 2D we have 4 directions: horizontal, vertical, forward slash and
backslash.

the direction can be reprsented by (row_delta, col_delta)

we also have an origin from where we start the scan.


a win scan consists of 2 directions in 2D tic-tac-toe:
    - we have a 'scan' direction which is a 1D vector in the
      direction that we're looking for matching pieces
    - we also ahve a 'cover' direction which is orthogonal which
      ensures that our scan covers then entire 2D plane
    - we also have an origin which represents where we start
      scanning, but if we imagine scanning from -inf to inf maybe
      we don't need an origin

row_win:
    cover_direction = (1, 0) # top to bottom
    scan_direction = (0, 1) # left to right
    origin = (X, 0) # top to bottom, left to right
